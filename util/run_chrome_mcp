#!/usr/bin/env bash
set -euo pipefail

# run_chrome_mcp - Manage Chrome DevTools instance with socat proxy for Ubuntu VM access
#
# This script starts/stops a dedicated Chrome instance with remote debugging on port 9222,
# and a socat proxy that exposes it on LAN_IP:9223 for Ubuntu VM to access.

# Configuration
CHROME_BIN="/Applications/Google Chrome.app/Contents/MacOS/Google Chrome"
STATE_DIR="$HOME/.chrome-mcp"
LOG_DIR="$STATE_DIR/logs"
CHROME_PID_FILE="$STATE_DIR/chrome.pid"
SOCAT_PID_FILE="$STATE_DIR/socat.pid"
CHROME_LOG="$LOG_DIR/chrome-mcp.log"
SOCAT_LOG="$LOG_DIR/socat-mcp.log"
CHROME_PORT=9222
SOCAT_PORT=9223
CHROME_PROFILE="$HOME/.chrome-mcp-profile"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Utility functions
print_error() {
    echo -e "${RED}ERROR: $*${NC}" >&2
}

print_success() {
    echo -e "${GREEN}$*${NC}"
}

print_warning() {
    echo -e "${YELLOW}WARNING: $*${NC}"
}

print_info() {
    echo "$*"
}

# Ensure state directories exist
ensure_dirs() {
    mkdir -p "$STATE_DIR" "$LOG_DIR"
}

# Get LAN IP
get_lan_ip() {
    if [[ -n "${LAN_IP:-}" ]]; then
        echo "$LAN_IP"
    else
        local ip
        ip=$(ipconfig getifaddr en0 2>/dev/null || true)
        if [[ -z "$ip" ]]; then
            print_error "Could not determine LAN IP on interface en0. Set LAN_IP and try again."
            exit 1
        fi
        echo "$ip"
    fi
}

# Check if process is running
is_process_running() {
    local pid=$1
    kill -0 "$pid" 2>/dev/null
}

# Wait for URL to be ready
wait_for_url() {
    local url=$1
    local max_attempts=${2:-15}
    local attempt=0

    while [[ $attempt -lt $max_attempts ]]; do
        if curl --silent --max-time 1 "$url" >/dev/null 2>&1; then
            return 0
        fi
        sleep 1
        ((attempt++))
    done
    return 1
}

# Check if port is in use
check_port() {
    local port=$1
    local pid_file=$2

    local port_info
    port_info=$(lsof -i "TCP:$port" -sTCP:LISTEN -t 2>/dev/null || true)

    if [[ -z "$port_info" ]]; then
        return 0  # Port is free
    fi

    # Port is in use
    local port_pid
    port_pid=$(echo "$port_info" | head -n1)

    # Check if it's our process
    if [[ -f "$pid_file" ]]; then
        local our_pid
        our_pid=$(cat "$pid_file")
        if [[ "$port_pid" == "$our_pid" ]]; then
            return 1  # Port in use by our process
        fi
    fi

    # Port in use by different process
    local cmd
    cmd=$(ps -p "$port_pid" -o comm= 2>/dev/null || echo "unknown")
    print_error "Port $port already in use by PID $port_pid ($cmd). Not starting."
    exit 1
}

# Start Chrome DevTools instance
start_chrome() {
    print_info "Starting Chrome DevTools instance..."

    # Check if Chrome binary exists
    if [[ ! -x "$CHROME_BIN" ]]; then
        print_error "Chrome binary not found at: $CHROME_BIN"
        exit 1
    fi

    # Check port
    if ! check_port "$CHROME_PORT" "$CHROME_PID_FILE"; then
        print_info "Chrome already running (PID $(cat "$CHROME_PID_FILE"))"
        return 0
    fi

    # Start Chrome in background
    "$CHROME_BIN" \
        --remote-debugging-port="$CHROME_PORT" \
        --remote-allow-origins='*' \
        --user-data-dir="$CHROME_PROFILE" \
        --no-first-run \
        --no-default-browser-check \
        >> "$CHROME_LOG" 2>&1 &

    local chrome_pid=$!
    echo "$chrome_pid" > "$CHROME_PID_FILE"

    # Wait for Chrome DevTools to be ready
    print_info "Waiting for Chrome DevTools to be ready..."
    if ! wait_for_url "http://127.0.0.1:$CHROME_PORT/json/version"; then
        print_error "Chrome DevTools failed to start on port $CHROME_PORT"
        rm -f "$CHROME_PID_FILE"
        exit 1
    fi

    print_success "Chrome DevTools started (PID $chrome_pid, 127.0.0.1:$CHROME_PORT)"
}

# Start socat proxy
start_socat() {
    print_info "Starting socat proxy..."

    # Check if socat is installed
    if ! command -v socat >/dev/null 2>&1; then
        print_error "socat not found. Please install it (e.g. brew install socat)."
        exit 1
    fi

    # Get LAN IP
    local lan_ip
    lan_ip=$(get_lan_ip)

    # Check if socat is already running but bound to wrong IP (network changed)
    if [[ -f "$SOCAT_PID_FILE" ]]; then
        local socat_pid
        socat_pid=$(cat "$SOCAT_PID_FILE")
        if is_process_running "$socat_pid"; then
            # Check what IP socat is currently bound to
            local bound_ip
            bound_ip=$(lsof -p "$socat_pid" -a -i "TCP:$SOCAT_PORT" -sTCP:LISTEN 2>/dev/null | awk 'NR>1 {print $9}' | cut -d: -f1 || true)
            if [[ -n "$bound_ip" && "$bound_ip" != "$lan_ip" ]]; then
                print_warning "socat is bound to old IP ($bound_ip), current LAN IP is $lan_ip"
                print_info "Restarting socat to bind to new IP..."
                kill "$socat_pid" 2>/dev/null || true
                sleep 1
                rm -f "$SOCAT_PID_FILE"
            fi
        fi
    fi

    # Check port
    if ! check_port "$SOCAT_PORT" "$SOCAT_PID_FILE"; then
        print_info "socat already running (PID $(cat "$SOCAT_PID_FILE"))"
        return 0
    fi

    # Start socat in background
    socat "TCP-LISTEN:$SOCAT_PORT,bind=$lan_ip,reuseaddr,fork" \
        "TCP:127.0.0.1:$CHROME_PORT" \
        >> "$SOCAT_LOG" 2>&1 &

    local socat_pid=$!
    echo "$socat_pid" > "$SOCAT_PID_FILE"

    # Give socat a moment to start
    sleep 1

    # Health check the proxy
    print_info "Checking proxy health..."
    if ! curl --silent --max-time 3 "http://$lan_ip:$SOCAT_PORT/json/version" >/dev/null 2>&1; then
        print_error "Proxy health check failed for http://$lan_ip:$SOCAT_PORT/json/version"
        rm -f "$SOCAT_PID_FILE"
        exit 1
    fi

    print_success "socat proxy started (PID $socat_pid, $lan_ip:$SOCAT_PORT -> 127.0.0.1:$CHROME_PORT)"
}

# Start command
cmd_start() {
    ensure_dirs
    start_chrome
    start_socat

    local lan_ip
    lan_ip=$(get_lan_ip)

    echo
    print_success "=== Chrome MCP DevTools Ready ==="
    print_info "Chrome DevTools: running (PID $(cat "$CHROME_PID_FILE"), 127.0.0.1:$CHROME_PORT, profile ~/.chrome-mcp-profile)"
    print_info "socat proxy: running (PID $(cat "$SOCAT_PID_FILE"), $lan_ip:$SOCAT_PORT -> 127.0.0.1:$CHROME_PORT)"
    print_success "Health check: OK (http://$lan_ip:$SOCAT_PORT/json/version)"
    echo
}

# Status command
cmd_status() {
    ensure_dirs

    local chrome_status="STOPPED"
    local socat_status="STOPPED"
    local chrome_pid=""
    local socat_pid=""
    local overall_healthy=true

    # Check Chrome
    if [[ -f "$CHROME_PID_FILE" ]]; then
        chrome_pid=$(cat "$CHROME_PID_FILE")
        if is_process_running "$chrome_pid"; then
            chrome_status="RUNNING"
        else
            chrome_status="STALE PID"
            overall_healthy=false
        fi
    else
        overall_healthy=false
    fi

    # Check socat
    if [[ -f "$SOCAT_PID_FILE" ]]; then
        socat_pid=$(cat "$SOCAT_PID_FILE")
        if is_process_running "$socat_pid"; then
            socat_status="RUNNING"
        else
            socat_status="STALE PID"
            overall_healthy=false
        fi
    else
        overall_healthy=false
    fi

    # Check ports
    local chrome_port_status=""
    local socat_port_status=""
    chrome_port_status=$(lsof -i "TCP:$CHROME_PORT" -sTCP:LISTEN 2>/dev/null | grep -v COMMAND || echo "")
    socat_port_status=$(lsof -i "TCP:$SOCAT_PORT" -sTCP:LISTEN 2>/dev/null | grep -v COMMAND || echo "")

    # HTTP checks
    local chrome_http="FAIL"
    local socat_http="FAIL"

    if curl --silent --max-time 2 "http://127.0.0.1:$CHROME_PORT/json/version" >/dev/null 2>&1; then
        chrome_http="OK"
    else
        overall_healthy=false
    fi

    local lan_ip
    lan_ip=$(get_lan_ip 2>/dev/null || echo "UNKNOWN")
    if [[ "$lan_ip" != "UNKNOWN" ]]; then
        if curl --silent --max-time 2 "http://$lan_ip:$SOCAT_PORT/json/version" >/dev/null 2>&1; then
            socat_http="OK"
        else
            overall_healthy=false
        fi
    fi

    # Print status
    echo
    echo "=== Chrome MCP DevTools Status ==="
    echo
    echo "Chrome DevTools:"
    echo "  Process: $chrome_status$([ -n "$chrome_pid" ] && echo " (PID $chrome_pid)" || echo "")"
    echo "  Port $CHROME_PORT: $([ -n "$chrome_port_status" ] && echo "IN USE" || echo "FREE")"
    echo "  HTTP check (http://127.0.0.1:$CHROME_PORT/json/version): $chrome_http"
    echo
    echo "socat proxy:"
    echo "  Process: $socat_status$([ -n "$socat_pid" ] && echo " (PID $socat_pid)" || echo "")"
    echo "  Port $SOCAT_PORT: $([ -n "$socat_port_status" ] && echo "IN USE" || echo "FREE")"
    if [[ "$lan_ip" != "UNKNOWN" ]]; then
        echo "  HTTP check (http://$lan_ip:$SOCAT_PORT/json/version): $socat_http"
    else
        echo "  HTTP check: SKIPPED (could not determine LAN IP)"
    fi
    echo

    if $overall_healthy; then
        print_success "Overall: HEALTHY"
    else
        print_error "Overall: UNHEALTHY"
    fi
    echo

    $overall_healthy
}

# Stop process helper
stop_process() {
    local name=$1
    local pid_file=$2

    if [[ ! -f "$pid_file" ]]; then
        print_info "$name already stopped (no PID file)"
        return 0
    fi

    local pid
    pid=$(cat "$pid_file")

    if ! is_process_running "$pid"; then
        print_info "$name already stopped (PID $pid not running)"
        rm -f "$pid_file"
        return 0
    fi

    print_info "Stopping $name (PID $pid)..."
    kill "$pid" 2>/dev/null || true

    # Wait up to 5 seconds for graceful shutdown
    local count=0
    while is_process_running "$pid" && [[ $count -lt 50 ]]; do
        sleep 0.1
        ((count++))
    done

    # Force kill if still running
    if is_process_running "$pid"; then
        print_warning "$name didn't stop gracefully, force killing..."
        kill -9 "$pid" 2>/dev/null || true
        sleep 0.5
    fi

    rm -f "$pid_file"
    print_success "$name stopped"
}

# Stop command
cmd_stop() {
    ensure_dirs

    # Stop socat first
    stop_process "socat proxy" "$SOCAT_PID_FILE"

    # Stop Chrome
    stop_process "Chrome DevTools instance" "$CHROME_PID_FILE"

    echo
    print_success "=== Stopped Chrome MCP DevTools ==="
    print_info "Ports $CHROME_PORT and $SOCAT_PORT should now be free."
    echo
}

# Restart command
cmd_restart() {
    print_info "Restarting Chrome MCP DevTools..."
    echo
    cmd_stop
    sleep 1
    cmd_start
}

# Help command
cmd_help() {
    cat <<'EOF'
run_chrome_mcp - Manage Chrome DevTools instance with socat proxy

USAGE:
    run_chrome_mcp {start|stop|status|restart|help}

COMMANDS:
    start       Start Chrome DevTools on 127.0.0.1:9222 and socat proxy on LAN_IP:9223
    stop        Stop both Chrome DevTools and socat proxy
    status      Show status of Chrome DevTools and socat proxy with health checks
    restart     Stop and start both services
    help        Show this help message

DESCRIPTION:
    This script manages a dedicated Chrome instance with remote debugging enabled,
    along with a socat proxy that exposes it to the local network for Ubuntu VM access.

    Chrome DevTools:
        - Runs on 127.0.0.1:9222 (localhost only)
        - Uses separate profile: ~/.chrome-mcp-profile
        - Does not interfere with your main Chrome windows

    socat proxy:
        - Listens on LAN_IP:9223
        - Forwards to 127.0.0.1:9222
        - Allows Ubuntu VM to access Chrome DevTools

ENVIRONMENT:
    LAN_IP      Optional. If set, uses this IP for socat binding.
                Otherwise auto-detects using 'ipconfig getifaddr en0'

EXAMPLES:
    # Start services
    run_chrome_mcp start

    # Check if running and healthy
    run_chrome_mcp status

    # Test from command line
    curl http://$(ipconfig getifaddr en0):9223/json/version

    # Stop services
    run_chrome_mcp stop

    # Restart if something goes wrong
    run_chrome_mcp restart

FILES:
    State:  ~/.chrome-mcp/
    Logs:   ~/.chrome-mcp/logs/
    PIDs:   ~/.chrome-mcp/{chrome,socat}.pid
    Profile: ~/.chrome-mcp-profile/

REQUIREMENTS:
    - Google Chrome installed at: /Applications/Google Chrome.app/Contents/MacOS/Google Chrome
    - socat (install via: brew install socat)
    - curl (included with macOS)

EOF
}

# Main
main() {
    local cmd="${1:-}"

    case "$cmd" in
        start)
            cmd_start
            ;;
        stop)
            cmd_stop
            ;;
        status)
            cmd_status
            ;;
        restart)
            cmd_restart
            ;;
        help|--help|-h)
            cmd_help
            ;;
        *)
            print_error "Unknown command: ${cmd:-<none>}"
            echo
            echo "Usage: run_chrome_mcp {start|stop|status|restart|help}"
            echo
            exit 1
            ;;
    esac
}

main "$@"
